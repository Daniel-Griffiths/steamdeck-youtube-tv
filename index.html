<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Youtube</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="script-src 'self' 'unsafe-inline';"
    />
  </head>
  <body>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>
    <webview
      id="webview"
      tabindex="0"
      src="https://www.youtube.com/tv?env_forceFullAnimation=true"
      httpreferrer="https://www.youtube.com/tv"
      style="height: 100vh; width: 100vw; background: #000"
      useragent="Mozilla/5.0 (Linux; Android 12) Cobalt/22.2.3-gold (PS4)"
    ></webview>
    <script>
      const webview = document.getElementById("webview");

      document.addEventListener("DOMContentLoaded", function () {
        webview.focus();
      });

      const VALVE_VENDOR_ID = "28de";

      const GAMEPAD_BUTTON = {
        CROSS: 0,
        CIRCLE: 1,
        SQUARE: 2,
        TRIANGLE: 3,
        DPAD_UP: 12,
        DPAD_DOWN: 13,
        DPAD_LEFT: 14,
        DPAD_RIGHT: 15,
      };

      const buttonMap = {
        [GAMEPAD_BUTTON.CROSS]: String.fromCharCode(0x0d),
        [GAMEPAD_BUTTON.CIRCLE]: "Escape",
        [GAMEPAD_BUTTON.DPAD_UP]: "Up",
        [GAMEPAD_BUTTON.DPAD_DOWN]: "Down",
        [GAMEPAD_BUTTON.DPAD_LEFT]: "Left",
        [GAMEPAD_BUTTON.DPAD_RIGHT]: "Right",
      };

      const REPEAT_DELAY = 400;
      const REPEAT_INTERVAL = 100;

      const repeatableButtons = new Set([
        GAMEPAD_BUTTON.DPAD_UP,
        GAMEPAD_BUTTON.DPAD_DOWN,
        GAMEPAD_BUTTON.DPAD_LEFT,
        GAMEPAD_BUTTON.DPAD_RIGHT,
      ]);

      const heldButtons = new Map();
      const buttonStates = new Map();

      function sendKey(keyCode, type) {
        webview.sendInputEvent({ type, keyCode });
      }

      function startKeyRepeat(buttonKey, keyCode) {
        stopKeyRepeat(buttonKey);
        sendKey(keyCode, "keyDown");

        const delayTimer = setTimeout(() => {
          const repeatTimer = setInterval(() => {
            sendKey(keyCode, "keyUp");
            sendKey(keyCode, "keyDown");
          }, REPEAT_INTERVAL);

          heldButtons.set(buttonKey, { repeatTimer, keyCode });
        }, REPEAT_DELAY);

        heldButtons.set(buttonKey, { delayTimer, keyCode });
      }

      function stopKeyRepeat(buttonKey) {
        const held = heldButtons.get(buttonKey);
        if (held) {
          clearTimeout(held.delayTimer);
          clearInterval(held.repeatTimer);
          sendKey(held.keyCode, "keyUp");
          heldButtons.delete(buttonKey);
        }
      }

      function isSteamDeckController(gamepad) {
        return gamepad.id.toLowerCase().includes(VALVE_VENDOR_ID);
      }

      function handleButtonChange(gamepadIndex, buttonIndex, pressed) {
        const buttonKey = `${gamepadIndex}-${buttonIndex}`;
        const keyCode = buttonMap[buttonIndex];

        if (!keyCode) return;

        if (repeatableButtons.has(buttonIndex)) {
          if (pressed) {
            startKeyRepeat(buttonKey, keyCode);
          } else {
            stopKeyRepeat(buttonKey);
          }
        } else {
          sendKey(keyCode, pressed ? "keyDown" : "keyUp");
        }
      }

      function pollGamepads() {
        const gamepads = navigator.getGamepads();

        for (const gamepad of gamepads) {
          if (!gamepad || !isSteamDeckController(gamepad)) continue;

          gamepad.buttons.forEach((button, buttonIndex) => {
            const buttonKey = `${gamepad.index}-${buttonIndex}`;
            const wasPressed = buttonStates.get(buttonKey) || false;
            const isPressed = button.pressed;

            if (isPressed !== wasPressed) {
              buttonStates.set(buttonKey, isPressed);
              handleButtonChange(gamepad.index, buttonIndex, isPressed);
            }
          });
        }

        requestAnimationFrame(pollGamepads);
      }

      pollGamepads();
    </script>
  </body>
</html>
